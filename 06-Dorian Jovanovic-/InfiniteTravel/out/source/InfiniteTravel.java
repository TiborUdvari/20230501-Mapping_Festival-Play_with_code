/* autogenerated by Processing revision 1290 on 2023-02-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;
import ddf.minim.analysis.*;
import ddf.minim.*;
import javax.sound.sampled.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class InfiniteTravel extends PApplet {



PeasyCam cam;

Particles[] particlesArray = new Particles[800];
backLines[] backLinesArray = new backLines[0];
Analysor s1;

float lastDist = 1510000;


float[] randomPosY = new float[5100];
float[] randomPosX = new float[5100];

int[] randomScale = new int[5100];
int[] randomScaleSmall = new int[5100];


boolean showCity = false;
boolean [] scenes = new boolean [7];
int camSpeed = 300;

PShader blur;
float vx = 0.3f;
float wesh;
int dim;
float travelSpeed;
float OriSpeed;

float rotA;
float doaflip;
float transition;

float distmaxCam = 150000;

boolean back = true;

float manualDist;

float freq1;

float circleSize =3000;

float bubbleCamDist = 321000.0f;

float floorRectsDist = 610000;

float startingPoint = 0;

public void setup() {

  /* size commented out by preprocessor */;
  //size(1000,1000,P2D);
  frameRate(60);
  blur = loadShader("blur.glsl");
  s1 = new Analysor(this, "synthwave-goose-blade-runner-2049.mp3", 60);

  cam = new PeasyCam(this, 600);

  ////////camera controls

  /*
   println(cam.getLookAt()));
   println(cam.getDistance()));
   println(cam.getRotations()));
   
   //set data
   
   //set coordonnée(x,y,z,Distance)
   cam.lookAt(0.0,0.0,0.0,2412.0);
   
   //set rotation (x,y,z)
   cam.setRotations(0.0,0.0,0.0);
   */

  cam.lookAt(width/2, height/2, 0.0f, 2412.0f);



  background(0);
  //loading All Instances
  for (int i=0; i < particlesArray.length; i++) {
    //particlesArray[i] = new Particles(random(700, 1200), random(200, 500));
    particlesArray[i] = new Particles(random(-50, width), random(900, 1200));
  }

  for (int i=0; i < backLinesArray.length; i++) {
    backLinesArray[i] = new backLines((random(width)), random(900, height+500));
  }

  //randomPosX, RandomPosY
  for (int i=0; i < randomPosY.length; i++) {
    //particlesArray[i] = new Particles(random(700, 1200), random(200, 500));
    randomPosY[i] = random(-height*4, height*4);
  }

  for (int i=0; i < randomPosX.length; i++) {
    //particlesArray[i] = new Particles(random(700, 1200), random(200, 500));
    randomPosX[i] =random(-width*4, width*4);
  }

  for (int i=0; i < randomScale.length; i++) {
    //particlesArray[i] = new Particles(random(700, 1200), random(200, 500));
    randomScale[i] =PApplet.parseInt(random(10, 1000));
  }


  for (int i=0; i < randomScaleSmall.length; i++) {
    //particlesArray[i] = new Particles(random(700, 1200), random(200, 500));

    randomScaleSmall[i] =PApplet.parseInt(random(10, 500));
  }
}


public void draw() {

  /////////Camera Clipping
  float fov = PI/3.0f;
  float cameraZ = (height/2.0f) / tan(fov/2.0f);
  perspective(fov, PApplet.parseFloat(width)/PApplet.parseFloat(height),
    cameraZ/1.0f, cameraZ*10000.0f);
  //////// Printscreen with key == 's'
  printScreen();
  //////// Sins value for camera movement back and forth
  float sinTravel = sin((float)frameCount*0.005f)*100;
  float sinAngle = sin((float)frameCount*0.00f)*10;
  travelSpeed = map(sinTravel, 100, -100, 150000, 1);
  OriSpeed = map(sinAngle, -1, 1, -0.005f, 0.005f);
  //////// Debug
  //println(sinTravel);
  //println("camdist: "+ cam.getDistance());
  //cam.setRotations(0.0, OriSpeed, 0.0);
  //////// Camera movement with keys
  if (keyPressed == true) {
    if (key=='a') {
      rotA+=0.001f;
      cam.setRotations(0.0f, rotA, doaflip);
    }
    if (key=='d') {
      rotA-=0.001f;
      cam.setRotations(0.0f, rotA, doaflip);
    }
    
    if (key=='x') {
      doaflip+=0.01f;
      //transition+=20;
      cam.setRotations(0.0f, rotA, doaflip);
    }
    if (key=='u') {
      lastDist-=1500;
      //cam.lookAt(width/2, height/2, 0.0, manualDist);
      //cam.lookAt(width/2, height/2, 0.0, manualDist, (long)1);
      for (int i = 0; i<=100; i++) {
        //manualDist = lerp(0,-500,i/100);
      }
      //manualDist=0;
    }
    if (key=='j') {
      lastDist+=1500;
      //cam.lookAt(width/2, height/2, 0.0, manualDist, (long)1);
      for (int i = 0; i<=10; i++) {
        //manualDist += lerp(manualDist-500,manualDist,i/10);
      }
      //manualDist=0;
    }
  }


  if (lastDist>9000) {
    //lastDist-=300;
  } else {
    camSpeed = 50;
  }
  
  if(scenes[6]){
    camSpeed = 455;
  }
  
  if(scenes[5]){
  camSpeed = 410;
  }

  if(lastDist<308055&&lastDist>300000){
  camSpeed = 100;
  }
  
  if(scenes[3]){
  camSpeed = 100;
  }
  lastDist-=camSpeed;
  

  //lastDist-=300;
  cam.lookAt(width/2, height/2, 0.0f, lastDist, (long)1);
  /////Camera automatic Mouvement Sin
  // cam.lookAt(width/2, height/2, 0, travelSpeed);
  //cam.lookAt(width/2, height/2, 0.0, manualDist);
  ///soundscam
  //cam.lookAt(width/2, height*0.75, 0, distmaxCam -=s1.getChannel(17)*100);

  /////Camera manual Mouvement


  //bubbleCamDist-=500;
  //cam.lookAt(width/2, height/2, 0, bubbleCamDist);
  //println(manualDist);
  //Bubbles dist: 321000.0
  //background(0);

  /////Camera data distance convertion to Float, for making elements following the camera
  double dZ = cam.getDistance();
  float fZ = (float)dZ;

  /////Front World Background
  rectMode(CENTER);
  pushMatrix();
  translate(0, 0, fZ-25000);
  //fill(0, 50);
  noStroke();
  if (keyPressed) {
    if (key == 'l') {
      back = true;
    }
    if (key == 'p') {
      back = false;
    }
  }
  if (back) {
    fill(0, 100);
    rect(width/2, height/2, 1000000, 1000000);
  } else {
    fill(0, 0);
    rect(width/2, height/2, 1000000, 1000000);
    filter(blur);
    fill(0, 0);
    //rect(width/2, height/2, 10000, 10000);
   // filter(blur);
  }
  popMatrix();


  ////Infinite Travel
  //boolean [] valueForSwitch = funcMapValueForSwitch(bubbleCamDist);
  println("cam Z position: " + lastDist);
  showScenes(funcMapValueForSwitch(lastDist));
  /////Sound data analyse
  s1.runAnalyse();
  //s1.drawPreAnalyse(0, 0, width, 300);
  /////Lumière plafond
  for (int i = 0; i<100; i++) {
    pushMatrix();
    rotateX(PI/2);
    translate(0, 0, 0);
    fill(255, 255);
    noStroke();
    //rect(width/2, i*500, width/2, 20);
    popMatrix();
  }
  ///Floor Camera
  pushMatrix();
  translate(0, height, fZ-2000);
  rotateX(PI/2);
  fill(0, 35);
  //stroke(0, 255, 255);
  //rect(width/2, height/2, width, 30000);
  popMatrix();

  //second floor
  /* pushMatrix();
   translate(0, 900, fZ-2000);
   rotateX(PI/2);
   fill(0, 20);
   stroke(0, 255, 255);
   rect(width/2, 0, width/2, 30000);
   popMatrix();
   */
  /*for (int i=0; i < backLinesArray.length; i++) {
   backLinesArray[i].display(i, 20);
   }*/

  //filter(blur);

  //city floor
  pushMatrix();
  translate(0, height, 0);
  rotateX(PI/2);
  fill(0, 35);
  //stroke(0, 255, 255);
  //rect(width/2, height/2, width, 20000);
  popMatrix();
  /// Buildings


  //// CITY SCENE
  pushMatrix();
  //translate(width/2,height/2);
  if (showCity) {
    for (int i=0; i < particlesArray.length; i++) {
      //particlesArray[i/10].displayLights(100);
      particlesArray[i].display(i, 10, showCity);
    }
  }
  popMatrix();
  fill(0);
  noStroke();




  //SCENE 8 SQUARES FAST PORTAL
  pushMatrix();
  translate(0, 0, 942000);
  for (int i = 0; i<1000; i++) {

    translate(0, 0, 300);
    //rotate(0.1);
    //fill(255);
    noFill();
    stroke(0, 255, 255);
    rect(width/2, height/2, 5000-(i*100), 5000-(i*100));
    //rotate(i/100);
  }
  popMatrix();
  //SCENE 8 SQUARES rotated FAST PORTAL
  pushMatrix();
  translate(0, 0, 1120000);
  for (int i = 0; i<1000; i++) {

    translate(0, 0, 300);
    //rotate(0.1);
    //fill(255);
    noFill();
    stroke(0, 255, 255);
    rect(width/2, height/2, 5000-(i*100), 10000-(i*100));
    //rotate(i/100);
  }
  popMatrix();


  //SCENE 8 SQUARES rotated FAST PORTAL
  pushMatrix();
  translate(0, 0, 1311000);
  for (int i = 0; i<1000; i++) {

    translate(0, 0, 300);
    rotate(0.1f);
    //fill(255);
    noFill();
    stroke(0, 255, 255);
    rect(width/2, height/2, 5000-(i*100), 5000-(i*100));
    //rotate(i/100);
  }
  popMatrix();
}


public void printScreen() {

  if (keyPressed == true) {
    if (key=='s') {
      save("Pictures/"+hour()+"."+minute()+"."+second()+"_"+day()+"."+month()+"_"+"InfiniteTravel.jpg");
    }
  }
}


public boolean [] funcMapValueForSwitch (float numberToCheck) {

  
  if (numberToCheck>=0 && numberToCheck <= 20000) scenes[0] = true;
  else scenes[0] = false;

  if (numberToCheck>=15000 && numberToCheck <= 90000) scenes[1] = true;
  else scenes[1] = false;

  if (numberToCheck>=84000 && numberToCheck <= 162000) scenes[2] = true;
  else scenes[2] = false;

  if (numberToCheck>=120000 && numberToCheck <= 222000) scenes[3] = true;
  else scenes[3] = false;

  if (numberToCheck>=201000 && numberToCheck <= 327000) scenes[4] = true;
  else scenes[4] = false;

  if (numberToCheck>=310000 && numberToCheck <= 836500) scenes[5] = true;
  else scenes[5] = false;

  if (numberToCheck>=836500 && numberToCheck <= 942000) scenes[6] = true;
  else scenes[6] = false;

  println(scenes);
  return scenes;
}

public void showScenes(boolean [] valueForSwitch) {

  if (valueForSwitch[0]) {
    println("Scene 1 IS printing");
    showCity = true;
  } else {
    showCity =false;
  }
  ///// BLUE RECTS PORTALS
  if (valueForSwitch[1]) {
    println("Scene 2 IS printing");
    pushMatrix();
    for (int i = 0; i<100; i++) {
      if (i==1)translate(0, 0, 15000);
      translate(0, 0, i*10);
      //fill(255);
      noFill();
      stroke(0, 255, 255);
      rect(width/2, height/2, 5000-(i*100), 5000-(i*100));
      rotate(i/100);
      stroke(255, 255, 255);
      //rect(width/2, height/2, width, height);
      stroke(0, 255, 255);
      //rect(width/2, height/2, width*3, height*3);
    }
    popMatrix();
  }

  ////SPIRALE WHITE RECT
  if (valueForSwitch[2]) {
    println("Scene 3 IS printing");
    pushMatrix();
    translate(width/2, height/2, 0);
    for (int i = 0; i<1000; i++) {
      if (i==1)translate(0, 0, 85000);
      translate(0, 0, 50);
      noFill();
      rotate(i/10);
      stroke(255, 255, 255);
      rect(width/2, height/2, 50, 50);
    }
    popMatrix();
  }

  ////SPIDER SCENE
  if (valueForSwitch[3]) {
    println("Scene 4 printing");
    pushMatrix();
    translate(width/2, height/2, 0);
    for (int i = 0; i<4000; i++) {
      if (i==1)translate(0, 0, 120000);
      translate(0, 5, 20);
      rotate(i/10);
      stroke(255, 50);
      line(width/2, height/2, 0, height);
      fill(255, 255, 255);
      stroke(0, 255, 255);
      // circle(width/2, height/2, 50);
    }
    popMatrix();
  }

  ////BUBBLES SCENE
  if (valueForSwitch[4]) {
    println("Scene 5 printing");
    //circle
    pushMatrix();
    for (int i = 0; i<4000; i++) {
      int zder;
      if (i==1)translate(0, 0, 200000);
      noFill();
      //circle(width/2, i+height/2, 1000);
      translate(0, 0, 20);
      if (i%2==0) {
        stroke(255, 255, 255);
      } else {
        stroke(0, 255, 255);
      }
      if (i%3==0) {
        zder = randomScaleSmall[i];
        noStroke();
        fill(255);
      } else {
        fill(0, 0, 0);
        zder = randomScale[i];
      }
      // noFill();
      strokeWeight(1);
      circle(randomPosX[i], randomPosY[i], zder);
      /* stroke(255);
       strokeWeight(0.5);
       line(randomPosX[i], randomPosY[i], randomPosX[i+1], randomPosY[i+1]);
       */
    }
    popMatrix();
    ////Squares beofre bubbles
    pushMatrix();
    // translate(0, -5000, 310000);
    translate(width/2, height/2, 301250);
    for (int i = 0; i<10; i++) {
      int size = 0;
      if (i%3==0) size = 200;
      fill(255);
      if (i%2==0) size = 50;
      fill(0);
      if (i%100==0) size = 3000;
      fill(0);
      translate(0, 0, 300);
      stroke(0, 255, 255);
      noFill();
      rect(0, 0, width, height);
    }
    popMatrix();
  }

  /////SCENE 6
  if (valueForSwitch[5]) {
    //Scene 6
    //println("Scene 6 printing");
    //// CIRCLES SKY
    pushMatrix();
    translate(0, -5000, 310000);
    for (int i = 0; i<1000; i++) {
      int size = 0;
      if (i%3==0) {
        size = 50+PApplet.parseInt(s1.getChannel(5));
        fill(0);
        stroke(0,255,255);
      }
      if (i%2==0) {
        size = 50;
        
        fill(s1.getChannel(5));
        stroke(0,255,255,s1.getChannel(5));
      }
      if (i%80==0) {
        size = 3000;
        fill(0);
      }
      translate(0, 0, 500);
      stroke(0, 255, 255);
      circle(randomPosX[i], randomPosY[i], size);
    }
    popMatrix();

    //Squares floor
    pushMatrix();
    translate(-width, height, 310000);
    //translate(-10025, height, 10000);
    rotateX(PI/2);
    for (int x = 0; x<300000; x+=1000) {
      //if (x==0)translate(0, 0, 327000);
      for (int y = 0; y<50000; y+=1000) {
        // if (y==0)translate(0, 0, 327000);
        fill(0);
        stroke(0, 255, 255);
        if (x%1000==0) {
        } else {
          noFill();
        }
        rect(y, x, 1000, 1000);
      }
    }
    popMatrix();
    //Scene 6
    /////BROKEN FLOOR
    pushMatrix();
    translate(-width, height-50, 610000);
    //translate(-10000, height, 3000);
    rotateX(PI/2);
    for (int x = 0; x<300; x++) {
      //if (x==0)translate(0, 0, 327000);
      for (int y = 0; y<30; y++) {
        // if (y==0)translate(0, 0, 327000);
        fill(0);
        stroke(0, 255, 255);
        if (x%1==0) {
          rotate(1*x);
        } else {
        }
        rect(y*1000, x*1000, 1000, 1000);
      }
    }
    popMatrix();
  }

  //Scene 7 Start at 836500.0
  if (valueForSwitch[6]) {
    //SCENE 7
    pushMatrix();
    translate(0, 0, 836500);
    for (int i = 0; i<400; i++) {
      int size = 5000;
      stroke(0, 255, 255);
      fill(0);
      if (i%3==0) {
        size = 5000;
        stroke(0, 255, 255);
        fill(0);
      }
      if (i%2==0) {
        size = 5000;
        stroke(0, 255, 255);
        fill(0);
      }
      if (i%5==0) {
        size = 5000;
        stroke(255, 255, 255);
        fill(0);
      }

      translate(0, 0, 200);
      //rotate(0.1);
      for (int w = 0; w<5; w++) {
        circle(randomPosX[i], (height*4), size-w*400);
      }
    }
    popMatrix();
  }
  //Scene 7 end at 942000.0


  //Scene 8 start at 942000.0
}
class Particles {

  int Y_AXIS = 1;
  int X_AXIS = 2;
  int b1, b2, c1, c2;
  //Particle Position Y
  float x;
  // Particle Position Y
  float y;
  //Particle velocity X
  float vx = random(-1, 1);
  // Particle velocity Y
  float vy = random(1, 2);

  // Particle color
  int couleur;
  float couleur2;
  float couleur3;
  float size1;
  int counter2;


  float x2;
  float y3;

  Particles(float posX, float posY) {
    //assign Particle position to fonction when called
    x = posX;
    y = posY;
    couleur = color(random(255));
  }

  int lightsCounter;
  public void displayLights(int numberOfLights) {

    lightsCounter++;
    if (lightsCounter <= numberOfLights) {
    }

    float sin1 = sin((float)frameCount*0.009f)*1;
    couleur2 = map(sin1, -1, 1, 0, 255);


    float sin2 = sin((float)frameCount*0.01f)*100;
    float blinkingLights = map(sin2, -1, 1, 0, 255);
    //x+= vx;
    //translate(0, 0, 30);

    stroke(255, 50);
    line(x, y-300, x, y+couleur2/2);
    fill(255, 255, 255, blinkingLights);
    stroke(0, 255, 255);
    circle(x, y-300, couleur2*0.05f);
  }

  public void display(int loopnumber, int randomZ, boolean cityDisplay) {


    //float change2 = sin((float)frameCount*0.01)*100;
    // float change3 = sin((float)frameCount*0.001)*20;

    //float  buildingHeight = map(change3, -1, 1, 100, 150);
    int  buildingHeight = 400;
    // float couleur90 = map(change3, -1, 1, 125, 255);
    //float couleur3 = map(change3, -1, 1, 255, 0);

    // stroke(0, couleur90, couleur90, 10);
    //fill(0,couleur2,couleur2,-1*couleur2);
    //fill(20,20,20,couleur90);

    // counter2+=10;
    //println(loopnumber);

    int module = loopnumber%3;
    float buildingWidth = 15;

    if (module == 0) {
      buildingWidth = 50;
    }
    if (module ==1) {
      buildingWidth = 40;
    }
    if (module == 2 ) {
      buildingWidth = 20;
    }





    //random Z POS
    translate(0, 0, randomZ);

    //rotateX(mouseX);
    //rotateZ(loopnumber);

    //Buildings backlight blue


    pushMatrix();

    stroke(0, 255, 255);
    translate(0, 0, -10);
    //fill(0, 255, 255);
    noFill();

    if (cityDisplay) rect(x, y, buildingWidth, buildingHeight*2);
   


    //Buildings backlight white
    
    translate(0, 0, -10);
    //fill(255,50);
    noFill();
    stroke(255);
    if (cityDisplay) rect(x, y, buildingWidth, buildingHeight*2);
    popMatrix();

    //mainBuildings
    fill(0);
    stroke(255, 100);
    if (cityDisplay) rect(x, y, buildingWidth, buildingHeight*2);

    //windows
    for (int i = 0; i <= 40; i++) {
      if (cityDisplay) x2 = lerp(x, x, i/50.0f);
     if (cityDisplay) y3 = lerp((y-buildingHeight)+10, y+buildingHeight, i/50.0f);
      pushMatrix();
      int rectw = 3;
      int recth = 3;
      int restex = i % 3;

      if (restex == 0) {
        fill(255, 255, 255);
        recth = 3;
        rectw = 3;
       if (cityDisplay) x2 += buildingWidth/10;
      }
      if (restex ==1) {
        stroke(255, 255, 255);
        recth = 5;
        rectw = 2;
       if (cityDisplay) x2 -= buildingWidth/10;
      }
      if (restex ==2 ) {
        //noStroke();
        fill(255, 255, 255);
        recth = 5;
        rectw = 2;
        if (cityDisplay) x2 += buildingWidth/10;
      }

      
      translate(0, 0, 5);
      if (!cityDisplay) rectw = 0;
      if (!cityDisplay) recth = 0;
      rect(x2, y3, rectw, recth);
      popMatrix();
    }
  }
}




public class Analysor {

  boolean debug=true;

  //------------------------------------------------------------
  //>> MINIM AND ANALYSIS SYSTEM
  //------------------------------------------------------------
  private PApplet app;
  Minim minim;  

  BeatDetect beat;

  FFT fftLin;
  String path;
  int echan;

  AudioPlayer jingle;
  AudioInput in;

  AudioSource source; 

  float senbility=1;
  float [] tabChannel;
  boolean [] pointer;

  //------------------------------------------------------------
  //>> CONSTRUCTOR FOR MP3
  //------------------------------------------------------------
  Analysor(PApplet app, String path, int echan) {
    this.app=app;
    this.path=path;
    this.echan=echan;
    minim = new Minim(app);

    jingle = minim.loadFile(path);
    jingle.loop();
    
    initAnalysor();
  }
  //------------------------------------------------------------
  //>> CONSTRUCTOR FOR LINE IN
  //------------------------------------------------------------
  Analysor(PApplet app, int echan) {
    this.app=app;
    this.path=path;
    this.echan=echan;
    minim = new Minim(app);

    in = minim.getLineIn();

    initAnalysor();
  }

  public void initAnalysor() {
    if (jingle!=null)source = jingle;
    if (in!=null)source = in;

    fftLin = new FFT( source.bufferSize(), source.sampleRate());
    //fftLin.linAverages(echan);
    fftLin.logAverages( echan, 10 );

    beat = new BeatDetect();
    beat.detectMode(BeatDetect.FREQ_ENERGY);
    beat.setSensitivity(500);

    this.app.registerMethod("keyEvent", this);
    //noSmooth();
    pointer = new boolean[fftLin.avgSize()];
    tabChannel = new float[fftLin.avgSize()];
    for (int i=0; i<pointer.length; i++)pointer[i]=false;
  }
  //-------------------------------------------------------------
  //  RUN SYSTEM
  //-------------------------------------------------------------
  public void runAnalyse() {
    beat.detect(source.mix);
    if (jingle!=null)fftLin.forward( jingle.mix );
    if (in!=null)fftLin.forward( in.mix );
    
    for(int i=0;i<tabChannel.length;i++)tabChannel[i]=fftLin.getAvg(i)*senbility;
    
  }
  //-------------------------------------------------------------
  //  DRAW PRE ANALYSE DU SYSTEME
  //-------------------------------------------------------------
  int margeH=90;
  int margeV=30;

  public void drawPreAnalyse(int x, int y, int w, int h) {
    if (debug) {
      //--------------------------------------------------
      //  FOND NOIR
      //--------------------------------------------------
      strokeWeight(1);
      pushStyle();
      rectMode(CORNER);
      noStroke();
      fill(0);
      rect(x, y, w, h);

      fill(255);
      text("Graphic Analyser \nHelper Class for student "+"\nSensibility : "+senbility, x+20, y+20);

      text("Power : "+PApplet.parseInt(getPower()),x+margeH+500,y+margeV/2+10);
      rect(x+margeH+600,y+margeV/2,getPower(),10);

      float sLarg=PApplet.parseFloat(w-margeV*2)/fftLin.avgSize();

      for (int i = 0; i < fftLin.avgSize (); i++) {
        // draw a rectangle for each average, multiply the value by spectrumScale so we can see it better
        stroke(100);
        line(PApplet.parseInt(margeV+x+i*sLarg), y+h-margeH, PApplet.parseInt(margeV+x+i*sLarg), y+h-margeH-100);
        fill(255);
        noStroke();
        rect(PApplet.parseInt(margeV+x+i*sLarg), y+h-margeH, PApplet.parseInt(sLarg), - fftLin.getAvg(i)*senbility);

        //--------------------------------------------------
        //  affichage Fréquence
        //--------------------------------------------------
        pushMatrix();
        translate(PApplet.parseInt(margeV+x+i*sLarg), PApplet.parseInt(y+h-margeH+40));
        rotate(PI/2);
        text(PApplet.parseInt(fftLin.getAverageCenterFrequency(i)), 0, 0);
        popMatrix();

        //--------------------------------------------------
        //  affichage colonne
        //--------------------------------------------------
        if (pointer[i]==false) {
          fill(0, 255, 255);
        } else {
          fill(255, 40, 40);
        }

        pushMatrix();
        if (i%2==0) {
          translate(PApplet.parseInt(margeV+x+i*sLarg), PApplet.parseInt(y+h-margeH+20));
        } else {
          translate(PApplet.parseInt(margeV+x+i*sLarg), PApplet.parseInt(y+h-margeH+25));
        }
        text(i, 0, 0);
        popMatrix();
      }

      popStyle();
    }

    for (int i=0; i<pointer.length; i++)pointer[i]=false;
  }

  //--------------------------------------------------
  //  Student method usefull
  //--------------------------------------------------
  public float getChannel(int cha) {
    pointer[cha]=true;
    return fftLin.getAvg(cha)*senbility;
  }
  public int getNbreChannel() {
    return fftLin.avgSize();
  }

  public boolean getBeat() {
    return beat.isOnset();
  }
  
  public boolean getSnare() {
    return beat.isSnare();
  }
  
  public float getPower(){
    float result=0;
    for(int i=0;i<tabChannel.length;i++)result+=tabChannel[i]*senbility;
    result/=tabChannel.length;
    return result;
  }
  
  //--------------------------------------------------
  //  setter
  //--------------------------------------------------
  public void volume(float vol){
    source.setVolume(vol);
  }
  
  public void changeMixerChannel(int channel){
        Mixer.Info[] mixerInfo;
        mixerInfo = AudioSystem.getMixerInfo();
      
      Mixer mixer = AudioSystem.getMixer(mixerInfo[channel]);
      minim.setInputMixer(mixer);
      in = minim.getLineIn(Minim.STEREO);
  }
  
  //--------------------------------------------------
  //  keyEvent
  //--------------------------------------------------
  public void keyEvent(KeyEvent e) {
    println(e.getKeyCode());
    if (e.getAction()==e.RELEASE && e.getKeyCode()==32) {
      debug=!debug;
    }
    if (e.getAction()==e.RELEASE && e.getKeyCode()==38) {
      senbility+=.5f;
    }
    if (e.getAction()==e.RELEASE && e.getKeyCode()==40) {
      senbility-=.5f;
    }
  }


  //----------------------------------------------------------------------------------------------------
}
class backLines {



  float x;
  float y;

  float vy = 0.2f;
  int couleur;

  backLines(float posX, float posY) {

    x = posX;
    y = posY;

    couleur = color(random(255), 0, random(255));
  }

  public void display(int loopnumber, int randomZ) {

    
    
    stroke(0, 255, 255);

    stroke(couleur);
    
   

    //x+=vx;

    //line(x,y,x+100,y-10);
     

     

    for (int x2=0; x2 < 100; x2++) {
      int restex = x2 % 3;
      noFill();
      pushMatrix();
      stroke(couleur);
      
     // line(x, y-500*x2, 400, y-500*x2);
      popMatrix();

      //y+=vy/3;


      if (restex == 0) {
        //stroke(235, 8, 105);
        stroke(couleur);
      }
      if (restex ==1) {

        stroke(couleur);
      }
      if (restex ==2) {
        //stroke(244, 79, 202);
        stroke(couleur);
      }

      // line(x,y+x2*100,x+width,y+x2*100);

      stroke(0, 255, 255);

      //line(200, 100+x2*10, 400, 100+x2*10);

      //line(200, 100+x2*10, 400, 100+x2*10);
    }
    
    
  }
}


  public void settings() { fullScreen(P3D, SPAN); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "InfiniteTravel" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
